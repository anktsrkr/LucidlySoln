@using Lucidly.Common
@using Markdig
@using Markdown.ColorCode
@using Microsoft.AspNetCore.Components
@using System.Text.RegularExpressions
@using System.Text.Json

<div class="markdown">
	@{
		var contentList = new List<(string Type, string Value)>();
		var toolDetailsTimeline = new List<ToolDetails>();
		var openThinks = new Dictionary<int, string>();
		var regex = new Regex(@"<(think|tool_update|mcp_tool_update)>([\s\S]*?)(<\/\1>|$)|([^<>]+)", RegexOptions.Singleline);
		var matches = regex.Matches(MarkdownContent);
		int thinkIndex = 0;

		foreach (Match match in matches)
		{
			var tag = match.Groups[1].Value;
			var innerContent = match.Groups[2].Value;
			var textContent = match.Groups[4].Value;

			if (!string.IsNullOrWhiteSpace(innerContent))
			{
				if (tag == "think" && string.IsNullOrEmpty(match.Groups[3].Value)) // No closing </think>
				{
					openThinks[thinkIndex++] = innerContent;
				}
				else
				{
					contentList.Add((tag, innerContent));
				}
			}
			else if (!string.IsNullOrWhiteSpace(textContent))
			{
				contentList.Add(("text", textContent.Trim()));
			}
		}

		void RenderTimelineItems(string functionName)
		{
			var relevantItems = toolDetailsTimeline.Where(x => x.FunctionName == functionName);
			<Timeline>
				@foreach (var item in relevantItems)
				{
					var msg = item.Type switch
					{
						"function-request" => $"Requesting permission to run {item.FunctionName}",
						"function-approved" => $"Permission to run {item.FunctionName} granted",
						"function-rejected" => $"Permission to run {item.FunctionName} rejected",
						"mcp-request" => "Additional information required",
						_ => $"Result from {item.FunctionName}"
					};

					var (color, icon) = item.Type switch
					{
						"function-request" => ("#726d6d", IconType.Outline.ClockCircle),
						"function-approved" => ("green", IconType.Outline.CheckCircle),
						"function-rejected" => ("red", IconType.Outline.CloseCircle),
						"mcp-request" => ("orange", IconType.Outline.ExclamationCircle),
						_ => ("blue", IconType.Outline.RightCircle)
					};

					<TimelineItem Color="@color">
						<Dot>
							<Icon Type="@icon" Fill="@(item.Type == "mcp-request" || item.Type == "function-request" ? color : null)" Style="font-size: 20px;" />
						</Dot>
						<ChildContent>
							<Text Style="font-size:15px;font-style:italic">
								@msg
								@if (item.Type == "mcp-request")
								{
									<DynamicAntForm SchemaData="@item.McpFunctionArgs"
													OnSubmit="@(model => HandleMcpFormSubmit(item.PluginName, item.FunctionName, model))" />
								}
							</Text>
						</ChildContent>
					</TimelineItem>
				}
			</Timeline>
		}

		if (contentList.Count > 0)
		{
			foreach (var content in contentList)
			{
				switch (content.Type)
				{
					case "tool_update":
					case "mcp_tool_update":
						var detail = System.Text.Json.JsonSerializer.Deserialize<ToolDetails>(content.Value, new JsonSerializerOptions
						{
							WriteIndented = true,
							Converters = { new PropertySchemaConverter() }
						});
						if (detail != null)
						{
							detail.FunctionName ??= toolDetailsTimeline.LastOrDefault()?.FunctionName ?? "Unknown";
							toolDetailsTimeline.Add(detail);

							if (detail.Type == "function-request")
							{
								RenderTimelineItems(detail.FunctionName);
							}
						}
						break;

					case "think":
						RenderThink(content.Value, "Thought Process");
						break;

					case "text":
						@((MarkupString)ConvertMarkdownToHtml(content.Value))
					// <EchoTag Text="@((MarkupString)ConvertMarkdownToHtml(content.Value))"	/>
						break;
				}
			}
		}

		if (openThinks.Count > 0)
		{
			foreach (var kvp in openThinks)
			{
				RenderThink(kvp.Value, "Thinking...", true);
			}
		}

		void RenderThink(string value, string headerText, bool expanded = false)
		{
			var guid = Guid.NewGuid().ToString(); var defaultKey = expanded ? new[] { guid } : Array.Empty<string>();
			<Collapse Style="margin-bottom:20px;width:100%" DefaultActiveKey="@defaultKey">
				<ExpandIconTemplate>
					<Icon Type="@IconType.Outline.CaretRight" Rotate="@(context ? 90 : 0)" />
				</ExpandIconTemplate>
				<ChildContent>
					<Panel Key="@guid">
						<HeaderTemplate>
							<Space>
								<SpaceItem>
									<Icon Type="bulb" Theme="IconThemeType.TwoTone" Width="1.5em" Height="1.5em" />
								</SpaceItem>
								<SpaceItem>
									<Text Strong>@headerText</Text>
								</SpaceItem>
							</Space>
						</HeaderTemplate>
						<ChildContent>
							<p>@((MarkupString)ConvertMarkdownToHtml(value))</p>
						</ChildContent>
					</Panel>
				</ChildContent>
			</Collapse>
		}
	}
</div>

@code {
	[Parameter] public string MarkdownContent { get; set; }

	[Parameter]
	public MarkdownPipeline Pipeline { get; set; } = new MarkdownPipelineBuilder()
		.UseAdvancedExtensions()
		.UseColorCode()
		.Build();

	private string ConvertMarkdownToHtml(string markdown) =>
		Markdig.Markdown.ToHtml(markdown, Pipeline);

		private void HandleMcpFormSubmit(string pluginName, string functionName, Dictionary<string, object> submittedValues)
{
    Console.WriteLine($"MCP Request Submitted: {pluginName}.{functionName}");
    foreach (var kvp in submittedValues)
    {
        Console.WriteLine($"{kvp.Key} = {kvp.Value}");
    }

    // Send back to the agent/MCP logic
    // e.g., invoke Semantic Kernel plugin or call an API
}
}
